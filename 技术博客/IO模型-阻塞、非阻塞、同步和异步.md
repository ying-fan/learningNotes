# IO模型-阻塞、非阻塞、同步和异步

## 一、引言

**同步异步I/O**，**阻塞非阻塞I/O**是程序员老生常谈的话题了，也是自己一直以来懵懵懂懂的一个话题。比如：<u>何为同步异步？何为阻塞与非阻塞？二者的区别在哪里？阻塞在何处？为什么会有多种IO模型，分别用来解决问题？常用的框架采用的是何种I/O模型？各种IO模型的优劣势在哪里，适用于何种应用场景？</u>

简而言之，对于I/O的认知，不能仅仅停留在字面上认识，了解内部玄机，才能深刻理解I/O，才能看清I/O相关问题的本质。



## 二、I/O 的定义

I/O（**I**nput/**O**utput） 即**输入／输出** 。

### 1. 计算机视角

**我们先从计算机结构的角度来解读一下 I/O。**

根据冯.诺依曼结构，计算机结构分为 5 大部分：运算器、控制器、存储器、输入设备、输出设备。

![](assets/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303139303632343132323132363339382e6a7065673f782d6f73732d70726f636573733d696d6167652f77617465726d61726b2c747970655f5a6d46755a33706f5a57356e6147567064476b2c7-16287673145013.jfif)

输入设备（比如键盘）和输出设备（比如鼠标）都属于外部设备。网卡、硬盘这种既可以属于输入设备，也可以属于输出设备。

输入设备向计算机输入数据，输出设备接收计算机输出的数据。

**从计算机结构的视角来看的话， I/O 描述了计算机系统与外部设备之间通信的过程。**

所以I/O之于计算机，有两层意思：

1. I/O设备
2. 对I/O设备的数据读写

对于一次I/O操作，必然涉及2个参与方，一个输入端，一个输出端，而又根据参与双方的设备类型，我们又可以分为==**磁盘I/O**==，==**网络I/O**==（一次网络的请求响应，网卡）等。

### 2. 程序视角

应用程序作为一个文件保存在磁盘中，只有加载到内存到成为一个进程才能运行。应用程序运行在计算机内存中，必然会涉及到数据交换，比如读写磁盘文件，访问数据库，调用远程 API 等等。但我们编写的程序并不能像操作系统内核一样直接进行I/O操作。

因为为了确保操作系统的安全稳定运行，操作系统启动后，将会开启保护模式：将内存分为**内核空间**（也称为**内核态**，内核对应进程所在内存空间，控制计算机的硬件资源，并提供上层应用程序运行的环境）和**用户空间**（也称为**用户态**，即上层应用程序的活动空间，应用程序的执行必须依赖于内核提供的资源），进行内存隔离。我们构建的程序将运行在用户空间，用户空间无法操作内核空间，也就意味着用户空间的程序不能直接访问由内核管理的I/O，比如：硬盘、网卡等。

但操作系统向外提供API，其由各种类型的**系统调用（System Call）**组成，以提供安全的访问控制。所以应用程序要想访问内核管理的I/O，必须通过调用内核提供的**系统调用(system call）**进行**间接访问**。

所以I/O之于应用程序来说，强调的通过**向内核发起系统调用完成对I/O的间接访问**。换句话说应用程序发起的一次IO操作实际包含两个阶段：

1. **IO调用阶段**：应用程序进程向内核发起系统调用
2. **IO执行阶段**：内核执行IO操作并返回
   2.1. **准备数据阶段**：内核等待I/O设备准备好数据
   2.2. **拷贝数据阶段**：将数据从内核缓冲区拷贝到用户空间缓冲区

怎么理解准备数据阶段呢？
对于写请求：等待系统调用的完整请求数据，并写入内核缓冲区；
对于读请求：等待系统调用的完整请求数据；（若请求数据不存在于内核缓冲区）则将外围设备的数据读入到内核缓冲区。

![](assets/17175f198660204b)

而应用程序进程在发起IO调用至内核执行IO返回之前，应用程序进程/线程所处状态，就是我们下面要讨论的第二个话题**阻塞IO与非阻塞IO**。

## 三、IO 模型之阻塞I/O(BIO)

应用程序中进程在发起IO调用后至内核执行IO操作返回结果之前，若发起系统调用的线程一直处于等待状态，则此次IO操作为**阻塞IO**。阻塞IO简称**BIO（Blocking IO）**。其处理流程如下图所示：

![](assets/17175f198678bcde)

从上图可知当用户进程发起IO系统调用后，内核从准备数据到拷贝数据到用户空间的两个阶段期间**用户调用线程选择阻塞等待**数据返回。

**阻塞IO在两个阶段都是阻塞**！！

因此BIO带来了一个问题：如果内核数据需要耗时很久才能准备好，那么用户进程将被阻塞，浪费性能。为了提升应用的性能，虽然可以通过多线程来提升性能，但线程的创建依然会借助系统调用，同时多线程会导致频繁的线程上下文的切换，同样会影响性能。所以要想解决BIO带来的问题，我们就得看到问题的本质，那就是**阻塞**二字。

## 四、IO 模型之非阻塞I/O(NIO)

那解决方案自然也容易想到，将阻塞变为非阻塞，那就是用户进程在发起系统调用时指定为非阻塞，内核接收到请求后，就会立即返回，然后用户进程通过轮询的方式来拉取处理结果。也就是如下图所示：

![](assets/17175f198687b2b3)

应用程序中进程在发起IO调用后至内核执行IO操作返回结果之前，若发起系统调用的线程不会等待而是立即返回，则此次IO操作为非阻塞IO模型。非阻塞IO简称NIO，Non-Blocking IO。

**非阻塞IO和阻塞IO相似，区别在于第一阶段，在等待数据准备就绪的过程中，用户进程不会阻塞。**

然而，非阻塞IO虽然相对于阻塞IO大幅提升了性能，但依旧不是完美的解决方案，其依然存在性能问题，也就是**频繁的轮询**导致频繁的系统调用，会耗费大量的CPU资源。比如当并发很高时，假设有1000个并发，那么单位时间循环内将会有1000次系统调用去轮询执行结果，而实际上可能只有2个请求结果执行完毕，这就会有998次无效的系统调用，造成严重的性能浪费。有问题就要解决，那**NIO问题的本质就是频繁轮询导致的无效系统调用**。

## 五、IO模型之IO多路复用

解决NIO的思路就是**降解无效的系统调用**，如何降解呢？我们一起来看看以下几种IO多路复用的解决思路。

### 1. IO多路复用之select/poll

Select是内核提供的系统调用，它支持**一次查询多个系统调用的可用状态**（**一次轮询多个socket**），当任意一个结果状态可用时就会返回，用户进程再发起一次系统调用进行数据读取。换句话说，就是**NIO中N次的系统调用，借助Select，只需要发起一次系统调用**就够了。其IO流程如下所示：

![](assets/17175f198bf13c57)

**IO 多路复用模型中，线程首先发起 select 调用，询问内核数据是否准备就绪，等内核把数据准备好了，用户线程再发起 read 调用。read 调用的过程（数据从内核空间->用户空间）还是阻塞的。**

**IO 多路复用模型，通过减少无效的系统调用，减少了对 CPU 资源的消耗。**

但是，select有一个限制，就是**存在连接数限制**，针对于此，又提出了poll。其与select相比，主要是解决了**连接限制**。

select/poll 虽然解决了NIO重复无效系统调用用的问题，但同时又引入了新的问题。问题是：

1. 用户空间和内核空间之间，大量的数据拷贝
2. 内核循环遍历IO状态，浪费CPU时间

换句话说，select/poll虽然减少了用户进程的发起的系统调用，但内核的工作量只增不减。在高并发的情况下，内核的性能问题依旧。所以select/poll的问题本质是：**内核存在无效的循环遍历**。

### 2. IO多路复用之epoll

针对select/pool引入的问题，我们把解决问题的思路转回到内核上，**如何减少内核重复无效的循环遍历呢？**变主动为被动，**基于事件驱动**来实现。其流程图如下所示：

![](assets/17175f198d29b33a)

epoll相较于select/poll，多了两次系统调用，其中epoll_create建立与内核的连接，epoll_ctl注册事件，epoll_wait阻塞用户进程，等待IO事件。

![](assets/17175f198e87ddcc)

epoll，已经大大优化了IO的执行效率，但在IO执行的第一阶段：**等待数据准备阶段都还是被阻塞的**。所以这是一个可以继续优化的点。



## 六、IO 模型之信号驱动IO(SIGIO)

信号驱动IO与BIO和NIO最大的区别就在于，**在IO执行的数据准备阶段，不会阻塞用户进程**。

如下图所示：当用户进程需要等待数据的时候，会向内核发送一个信号，告诉内核我要什么数据，然后用户进程就继续做别的事情去了，而当内核中的数据准备好之后，内核立马发给用户进程一个信号，说”数据准备好了，快来查收“，用户进程收到信号之后，立马调用recvfrom，去查收数据。

![](assets/17175f19b6c42f1c)

乍一看，信号驱动式I/O模型有种异步操作的感觉，但是**在IO执行的第二阶段，也就是将数据从内核空间复制到用户空间这个阶段，用户进程还是被阻塞的**。

综上，你会发现，**不管是BIO还是NIO还是SIGIO，它们最终都会被阻塞在IO执行的第二阶段**。
那如果能将IO执行的第二阶段变成非阻塞，那就完美了。



## 七、IO 模型之异步IO(AIO)

异步IO（Asynchronous I/O）真正实现了IO全流程的非阻塞。用户进程发出系统调用后立即返回，内核等待数据准备完成，然后将数据拷贝到用户进程缓冲区，然后发送信号告诉用户进程**IO操作执行完毕**（与SIGIO相比，一个是发送信号告诉用户进程数据准备完毕，一个是IO执行完毕）。其流程如下：

![](assets/17175f19b8e85e2b)

异步 IO 是**基于事件和回调机制**实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。

所以，**之所以称为异步IO，取决于IO执行的第二阶段是否阻塞。因此前面讲的BIO，NIO和SIGIO均为同步IO**。



## 八、总结

![](assets/17175f19bb874153)

一个IO操作其实分成了两个步骤：**发起IO请求**和**实际的IO操作**（实际的IO操作又分为两步：**等待数据准备**、**将数据从内核缓冲区拷贝到用户空间缓冲区**）。

阻塞IO和非阻塞IO的区别在于第一步（发起IO请求），发起IO请求是否会被阻塞，如果阻塞直到完成那么就是传统的阻塞IO，如果不阻塞，那么就是非阻塞IO。

同步IO和异步IO的区别就在于第二个步骤是否阻塞：如果实际的IO读写阻塞请求进程，那么就是同步IO，因此阻塞IO、非阻塞IO、IO复用、信号驱动IO都是同步IO；如果不阻塞，而是操作系统帮你做完IO操作再将结果返回给你，那么就是异步IO。

- 同步阻塞I/O：
  - 当进程调用某些设计I/O操作的系统调用或库函数时，比如accept()、send()、recv()等，进程便暂停下来，等待I/O操作完成后再继续运行。
- 同步非阻塞I/O：（轮询）
  - 不会等待数据就绪，而是结合反复轮询来尝试数据是否就绪。
  - 与同步阻塞I/O相比，**同步非阻塞I/O好处是在一个进程中可以同时处理多个I/O操作，而不是阻塞在一个I/O操作上**
- 多路I/O就绪通知：（I/O复用）
  - **允许进程通过一种方法来同时监听所有文件描述符，并可以快速获得所有就绪的文件描述符，然后只针对这些文件描述符进行数据访问。**我们常用的select、poll、epoll等函数使用了I/O复用模型。
  - 与同步非阻塞I/O相比，I/O复用模型的优势在于**可以同时等待多个（而不只是一个）套接字描述符就绪**
- 信号驱动式I/O：
  - 需要开启套接字的信号驱动I/O功能，并通过sigaction系统调用安装一个信号处理函数。sigaction函数立即返回，我们的进程继续工作，即进程没有被阻塞。当数据报准备好时，内核会为该进程产生一个SIGIO信号，这样我们可以在信号处理函数中调用recvfrom读取数据报，也可以在主循环中读取数据报。无论如何处理SIGIO信号，这种模型的优势在于等待数据报到达期间不被阻塞。
- 异步I/O(AIO)：
  - 启动某个操作，并让内核在整个操作（包括等待数据和将数据从内核复制到用户空间）完成后通知应用进程。
  - 与信号驱动式I/O的区别在于：信号驱动式I/O在数据报准备好时就通知应用进程，应用进程还需要将数据报从内核复制到用户进程缓冲区；而异步I/O模型则是整个操作完成才通知应用进程，应用进程在整个操作期间都不会被阻塞。



## 问题

有人说 "阻塞模式挺好的, 应为在阻塞状态下, 用户进程会被挂起, 挂起就是说不会再占用CPU资源了"

我觉着 阻塞模型这不挺好么, 自己所请求的网络数据没有准备好, 然后把CPU让给别人用, 这不是很好么?

又有些人说 "非阻塞好, 非阻塞可以在用户进程请求的数据没有准备好的时候, 让内核立即给予响应, 然后用户进程可以干别的, 一会儿再来检查一下, 这样轮循" 

我觉着这样也没问题啊, 至少进程也没闲着啊, 只不过 进程虽然干了别的, 但也多干了一些活,例如轮询

相比起来, 貌似比阻塞省下了CPU资源给别人用; 而非阻塞是抓紧利用CPU资源, 但为了抓紧使用，缺同时走了不少多余的路,，比如不断地轮询 所以？？？？？？

```
假设你用 php-fpm，你的 php 程序中需要向外部接口请求。php-fpm 是阻塞的模型，那么每一个 Worker 进程在执行这些网络 I/O 的时候，是不是都阻塞了？假设你的 php-fpm 最大进程数有 500 个，那么同时进来了 500 个请求，是不是都阻塞在了网络 I/O 上了？那么接下来，php-fpm 已经无法处理第 501 个请求了。可是此时，由于在等待网络 I/O 响应，CPU 实际上并没有做什么工作，你会发现，CPU 闲的要死，但是却无法处理请求了。

那么非阻塞呢？用 Swoole 举例子。我们在网络 I/O 的时候，让它去等待响应，与此同时，处理下一个请求。那么，我们会发现，并发数上去了，CPU 的利用率变高了。

假设你在用 Redis 的时候，它返回数据是毫秒级别的，那么你认为，它是阻塞呢还是非阻塞呢？这个时候，这两个的概念就模糊了。具体你还是要实际判断。
```

```
如果只有一个套接字的情况下，使用阻塞IO是极好的，读到数据就返回。

但是如果在有很多套接字的情况下，比如有100个套接字:

如果使用阻塞IO，可能因为读取一个没有数据的套接字而阻塞剩下的99个套接字的数据处理，那么就会造成服务器的响应性很差。
如果使用非阻塞IO，那么就需要轮询这一百个套接字到底可不可以读取到数据，这个轮询操作会浪费CPU时间片，照样也不是一个高效的方式，套接字多了，照样性能很差。

那有没有一种比较好的方式来同时检测多个套接字是否可读可写，并且不浪费CPU时间片呢？那就是要用IO多路复用了，使用IO多路复用可以同时检测多个不同的套接字是否就绪。有多种IO多路复用的实现，其中包括select，poll, epoll, /dev/poll, kqueue等。
```



## 阅读原文

- JavaGuide IO 模型：[https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/basis/IO模型.md](https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/basis/IO模型.md)


- IO 模型知多少 | 理论篇：https://www.cnblogs.com/sheng-jie/p/how-much-you-know-about-io-models.html


- 什么是阻塞，非阻塞，同步，异步？：https://sowhatbigfatloser.com/shi-yao-shi-zu-sai-fei-zu-sai-tong-bu-yi-bu/

- 阻塞和非阻塞 都有优点, 我理解的对么：https://segmentfault.com/q/1010000010415760


