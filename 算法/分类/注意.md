# 位运算

- 根据 与运算 定义，设二进制数字 n ，则有：

> ​	若 n \& 1 = 0，则 n 二进制 最右一位 为 0 ，即该数为**偶数**；
> ​	若 n \& 1 = 1，则 n 二进制 最右一位 为 1 ，即该数为**奇数**。

- n−1： 二进制数字 n 最右边的 1 变成 0 ，此 1 右边的 0 都变成 1 。


- n \& (n - 1) ： 二进制数字 n 最右边的 1 变成 0 ，其余不变。


- 二进制数右需考虑该数是否为**正数**还是**负数**：


> 移将二进制数字 n 无符号右移一位（ **Java 中无符号右移为 ">>>"** ） 。



# 浮点数

- 由于计算机表示小数（包括float与double型小数）都有误差，我们不能直接用等号（==）来判断两个小数是否相等。如果两个小数的差的绝对值很小，如小于0.0000001，就可以认为它们相等：
  $$
  (num1 - num2) < 0.0000001
  $$



# 链表

- 当我们用一个指针遍历链表不能解决问题时，可以尝试用两个指针来遍历链表。可s以让其中一个指针遍历的速度快一些（比如一次在链表上走两步），或者让它先在链表上走若干步。



# 二叉树

- 如果要求处理一颗二叉树的遍历序列，则可以先找到二叉树的根节点，再基于根节点把整棵树的遍历序列拆分成左右子树对应的子序列，接下来再递归地处理这两个子序列。



# 数字排列

- 如果面试题是按照一定要求摆放若干个数字，则可以先求出这些数字的所有排列，然后一一判断每个排列是不是满足题目给定的要求。

# 字符串

- 如果需要判断多个字符是不是在某个字符串里出现过或者统计多个字符在某个字符串中出现的次数，那么我们可以考虑基于数组创建一个简单的哈希表，这样可以用很小的空间消耗来换取时间效率的提升。